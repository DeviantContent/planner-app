import { ChatAnthropic } from '@langchain/anthropic';
import { HumanMessage, AIMessage, SystemMessage } from '@langchain/core/messages';
import { StateGraph, END } from '@langchain/langgraph';
import { ToolNode } from '@langchain/langgraph/prebuilt';
import { LangChainTracer } from '@langchain/core/tracers/tracer_langchain';
import { CoachingState, CoachingStateType, UserContext } from './state';
import { coachingTools } from './tools';
import { supabaseAdmin } from '@/lib/supabase';

// Type-safe wrapper for tables not yet in generated types
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const db = supabaseAdmin as any;

// Create tracer lazily to ensure env vars are loaded
function getTracer() {
  console.log('Creating LangChainTracer with project:', process.env.LANGSMITH_PROJECT || process.env.LANGCHAIN_PROJECT || 'planner-app');
  console.log('LANGCHAIN_API_KEY set:', !!process.env.LANGCHAIN_API_KEY);
  console.log('LANGSMITH_API_KEY set:', !!process.env.LANGSMITH_API_KEY);

  return new LangChainTracer({
    projectName: process.env.LANGSMITH_PROJECT || process.env.LANGCHAIN_PROJECT || 'planner-app',
  });
}

// Initialize the model
const model = new ChatAnthropic({
  model: 'claude-sonnet-4-20250514',
  maxTokens: 1024, // Increased for bulk project creation
  temperature: 0.7,
});

// Bind tools to the model
const modelWithTools = model.bindTools(coachingTools);

// System prompt for the coaching agent
const getSystemPrompt = (context: {
  userId: string;
  timezone: string;
  currentTime: string;
  isEvening: boolean;
  shouldPlanTomorrow: boolean;
  projects?: Array<{ id: string; title: string; next_steps: Array<{ id: string; title: string }> }>;
  todaysPlan?: { goals: Array<{ title: string; completed: boolean }> } | null;
  tomorrowsPlan?: { goals: Array<{ title: string; completed: boolean }> } | null;
}) => `You are a veteran, world-class life and CEO coach communicating via SMS. You bring decades of experience coaching high-performers, with a deep focus on mental health and work/life balance.

USER ID (use this for all tool calls): ${context.userId}

CURRENT CONTEXT:
- Time: ${context.currentTime} (${context.timezone})
- Evening mode: ${context.isEvening ? 'Yes - time to wind down and plan tomorrow' : 'No'}
- Should plan tomorrow: ${context.shouldPlanTomorrow ? 'Yes - prioritize getting tomorrow planned' : 'Not yet'}
${context.todaysPlan ? `- Today's goals: ${context.todaysPlan.goals.map(g => `${g.completed ? '✓' : '○'} ${g.title}`).join(', ')}` : '- No plan set for today'}
${context.tomorrowsPlan ? `- Tomorrow's goals: Already planned` : '- Tomorrow: Not yet planned'}

ACTIVE PROJECTS:
${context.projects && context.projects.length > 0
  ? context.projects.map(p => `• ${p.title}${p.next_steps.length > 0 ? ` (Next: ${p.next_steps[0].title})` : ''}`).join('\n')
  : 'No active projects yet'}

YOUR ROLE:
${context.shouldPlanTomorrow && !context.tomorrowsPlan
  ? `Priority: Plan tomorrow NOW! It's ${context.currentTime} - we need 3 goals AND a time-blocked schedule before bed.`
  : context.isEvening && context.tomorrowsPlan
    ? 'Tomorrow is planned. Evening check-in: How did today go? Any wins to celebrate?'
    : context.isEvening
      ? 'Evening mode: Let\'s reflect on today, then lock in tomorrow\'s plan with goals + schedule.'
      : 'Support the user with their day - check progress, adjust plans, provide coaching.'}

PLANNING WORKFLOW:
1. First, use get_projects to understand their ongoing work
2. Use get_current_time to know when to prompt for planning
3. When planning the next day:
   - Ask about their calendar/commitments
   - Review active projects and pick the most important next steps
   - Create exactly 3 focused goals
   - Build a 30-minute block schedule (REQUIRED - see below)

SCHEDULE RULES:
- A schedule MUST be generated by end of day - this is non-negotiable
- You decide what information you need to build a good schedule (meetings, energy levels, deadlines, etc.)
- Gather info through natural conversation, then generate the schedule when ready
- If the user demands a schedule immediately, generate your best attempt with available info
- Use save_daily_plan to save both goals AND schedule together
- Schedule should include: wake time, work blocks, breaks, meals, wind-down time
- Align high-focus work with peak energy times (usually morning)

BULK PROJECT INTAKE:
When the user sends a large message with multiple projects or context about their work:
1. Parse out distinct projects (major initiatives, ongoing work streams)
2. For each project, use create_project to save it
3. For each project, identify 1-3 concrete next steps and use add_next_step
4. After creating everything, summarize what you captured
5. Ask if anything is missing or needs adjustment

Example: If user says "I'm working on launching a new product, need to hire 2 engineers, and planning my wedding"
- Create project: "Product Launch" with next steps
- Create project: "Hiring - 2 Engineers" with next steps
- Create project: "Wedding Planning" with next steps

SMS CONSTRAINTS (CRITICAL):
- Keep responses under 160 characters when possible
- Ask exactly ONE question at a time - NEVER ask multiple questions in a single message
- Be direct and actionable
- No fluff or lengthy explanations
- End each message with a single, clear question OR a single action item
- If you need multiple pieces of info, ask them in sequence across multiple messages

COACHING APPROACH:
- Reference their active projects when relevant
- Ask probing questions before giving advice
- Balance ambition with sustainability
- Challenge assumptions gently but directly
- Celebrate small wins

TOOLS:
- Use get_projects to see their ongoing work and next steps
- Use get_todays_plan and get_tomorrows_plan to check planning status
- Use save_daily_plan to save goals and schedule
- Use add_next_step to capture new action items
- Use complete_next_step when they finish something

Remember: sustainable high performance beats burnout. Guard their mental health fiercely.`;

// Main agent node - processes messages and decides next action
async function agentNode(state: CoachingStateType) {
  // Build system prompt with user context
  const systemPrompt = state.userContext
    ? getSystemPrompt(state.userContext)
    : getSystemPrompt({
        userId: state.userId,
        timezone: 'America/Chicago',
        currentTime: new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true }),
        isEvening: new Date().getHours() >= 17,
        shouldPlanTomorrow: new Date().getHours() >= 17,
        projects: [],
        todaysPlan: null,
        tomorrowsPlan: null,
      });

  const messages = [
    new SystemMessage(systemPrompt),
    ...state.messages,
  ];

  const response = await modelWithTools.invoke(messages);

  return {
    messages: [response],
  };
}

// Check if the agent should continue or end
function shouldContinue(state: CoachingStateType): 'tools' | 'respond' {
  const lastMessage = state.messages[state.messages.length - 1];

  // If the last message has tool calls, route to tools
  if (
    lastMessage &&
    'tool_calls' in lastMessage &&
    Array.isArray(lastMessage.tool_calls) &&
    lastMessage.tool_calls.length > 0
  ) {
    return 'tools';
  }

  // Otherwise, we're done - format response
  return 'respond';
}

// Extract the final response for SMS
function respondNode(state: CoachingStateType) {
  const lastMessage = state.messages[state.messages.length - 1];

  let response = '';
  if (lastMessage && 'content' in lastMessage) {
    response = typeof lastMessage.content === 'string'
      ? lastMessage.content
      : JSON.stringify(lastMessage.content);
  }

  return {
    response,
  };
}

// Create the tool node
const toolNode = new ToolNode(coachingTools);

// Build the graph
const workflow = new StateGraph(CoachingState)
  .addNode('agent', agentNode)
  .addNode('tools', toolNode)
  .addNode('respond', respondNode)
  .addEdge('__start__', 'agent')
  .addConditionalEdges('agent', shouldContinue, {
    tools: 'tools',
    respond: 'respond',
  })
  .addEdge('tools', 'agent')
  .addEdge('respond', '__end__');

// Compile the graph
export const coachingAgent = workflow.compile();

// Load user context from database
async function loadUserContext(userId: string, timezone: string): Promise<UserContext> {
  const now = new Date();
  const timeOptions: Intl.DateTimeFormatOptions = {
    timeZone: timezone,
    hour: 'numeric',
    minute: 'numeric',
    hour12: true,
  };
  const currentTime = now.toLocaleTimeString('en-US', timeOptions);
  const hour = parseInt(now.toLocaleTimeString('en-US', { timeZone: timezone, hour: 'numeric', hour12: false }));

  const today = now.toLocaleDateString('en-CA', { timeZone: timezone });
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  const tomorrowStr = tomorrow.toLocaleDateString('en-CA', { timeZone: timezone });

  // Load projects with their next steps
  const { data: projectsData } = await supabaseAdmin
    .from('planner_goals')
    .select(`
      id,
      title,
      tasks:planner_tasks(id, title, completed)
    `)
    .eq('user_id', userId)
    .eq('status', 'active')
    .order('priority', { ascending: false });

  const projects = (projectsData || []).map(p => ({
    id: p.id,
    title: p.title,
    next_steps: (p.tasks as Array<{ id: string; title: string; completed: boolean }> || [])
      .filter(t => !t.completed)
      .map(t => ({ id: t.id, title: t.title })),
  }));

  // Load today's plan
  const { data: todaysPlanData } = await db
    .from('planner_daily_plans')
    .select('goals')
    .eq('user_id', userId)
    .eq('plan_date', today)
    .single();

  // Load tomorrow's plan
  const { data: tomorrowsPlanData } = await db
    .from('planner_daily_plans')
    .select('goals')
    .eq('user_id', userId)
    .eq('plan_date', tomorrowStr)
    .single();

  return {
    userId,
    timezone,
    currentTime,
    isEvening: hour >= 17,
    shouldPlanTomorrow: hour >= 17,
    projects,
    todaysPlan: todaysPlanData ? { goals: todaysPlanData.goals as Array<{ title: string; completed: boolean }> } : null,
    tomorrowsPlan: tomorrowsPlanData ? { goals: tomorrowsPlanData.goals as Array<{ title: string; completed: boolean }> } : null,
  };
}

// Helper function to invoke the agent with conversation history
export async function invokeCoachingAgent(
  userId: string,
  userMessage: string,
  conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }> = [],
  timezone: string = 'America/Chicago'
): Promise<string> {
  // Load user context from database
  const userContext = await loadUserContext(userId, timezone);

  // Convert conversation history to LangChain messages
  const messages = conversationHistory.map((msg) =>
    msg.role === 'user'
      ? new HumanMessage(msg.content)
      : new AIMessage(msg.content)
  );

  // Add the new user message
  messages.push(new HumanMessage(userMessage));

  // Invoke the agent with tracer callback for LangSmith
  const result = await coachingAgent.invoke(
    {
      messages,
      userId,
      currentPhase: 'gathering',
      collectedInfo: {},
      userContext,
    },
    {
      callbacks: [getTracer()],
      configurable: {
        thread_id: userId,
      },
      runName: 'coaching-agent',
      metadata: {
        userId,
        messagePreview: userMessage.slice(0, 50),
      },
    }
  );

  return result.response || 'I had trouble generating a response. Please try again.';
}
